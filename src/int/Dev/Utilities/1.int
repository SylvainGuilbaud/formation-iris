ROUTINE Dev.Utilities.1 [Type=INT,Generated]
 ;Dev.Utilities.1
 ;Generated for class Dev.Utilities.  Do NOT edit. 08/14/2023 08:17:19AM
 ;;7A374377;Dev.Utilities
 ;
LoadConfigPerson(directory="c:\Development\Studio\PersonOnly.xml") methodimpl {
	set st = $system.OBJ.Load(directory, "ck")
	quit:('st)
	set classAccountHolder = ##class(%Dictionary.ClassDefinition).%OpenId("FCE.AccountHolder")
	set classCurrencyOrder = ##class(%Dictionary.ClassDefinition).%OpenId("FCE.CurrencyOrder")
	set propAccttoCO = ##class(%Dictionary.PropertyDefinition).%New()
	set propAccttoCO.Name = "CurrencyOrders",
	    propAccttoCO.Type = "FCE.CurrencyOrder",
	    propAccttoCO.Relationship = 1,
	    propAccttoCO.Cardinality = "many",
	    propAccttoCO.Inverse = "AccountHolder",
	    propAccttoCO.Description = "Exchanges that this customer made"
	set propAccttoCO.parent = classAccountHolder
	set propCOtoAcct = ##class(%Dictionary.PropertyDefinition).%New()
	set propCOtoAcct.Name = "AccountHolder",
	    propCOtoAcct.Type = "FCE.AccountHolder",
	    propCOtoAcct.Relationship = 1,
	    propCOtoAcct.Cardinality = "one",
	    propCOtoAcct.Inverse = "CurrencyOrders"
	set propCOtoAcct.parent = classCurrencyOrder
	set indexAcct = ##class(%Dictionary.IndexDefinition).%New()
	set indexAcct.Name = "AccountHolderIndex", indexAcct.Properties = "AccountHolder"
	set indexAcct.parent = classCurrencyOrder
	do classAccountHolder.%Save(), classCurrencyOrder.%Save()
	set compileList = "FCE.AccountHolder.cls,FCE.CurrencyOrder.cls"
	do $system.OBJ.CompileList(compileList, "ck") }
RemovePopulation(package,commit=0) [ SQLCODE,package ] methodimpl { New %ROWCOUNT,%ROWID,%msg,SQLCODE 
	if ($get(package) = "") {
		write !, "Please supply package or sub-package name as argument." return 1 }
	if commit {
		read !, "Changes will be saved and classes recompiled. Continue? No=>", cont
		return:($case($extract(cont), "Y":0, "y":0, :1)) 1
	} 
	set status = 1
	 ;---&sql(DECLARE rempop CURSOR FOR
 	 ;---		 SELECT parent, name FROM %Dictionary.PropertyDefinition
 	 ;---		 WHERE (parent %STARTSWITH :package) AND (parameters LIKE '%POPSPEC%')
 	 ;---		 UNION
 	 ;---		 SELECT name, null FROM %Dictionary.ClassDefinition
 	 ;---		 WHERE (name %STARTSWITH :package) AND (super LIKE '%Populate%')
 	 ;---		 ORDER BY parent)
 	 ;--- ** SQL PUBLIC Variables: %ROWCOUNT, %ROWID, %msg, SQLCODE, package
	 
	 ;---&sql(OPEN rempop)
	if $g(%rempop0162)'="" { s SQLCODE=-101 } else { try { s %rempop0162="%sqlcq."_$tr($namespace,"%_-$@:/\[]^ .","pudssssssssss")_$case($zu(115,2),0:".u",1:".x",3:".v",:"."_$zu(115,2))_"ER4K4js5ZNjXVzIgCt3xQ5JZcaf",%rempop0162=$classmethod(%rempop0162,"%New") } catch { if ($ze'["<CLASS DOES NOT EXIST>"&&($ze'["<NOROUTINE>")||($ze'[%rempop0162)),$ze'["<ZSQLU>" { throw } } if '$isobject(%rempop0162) { s %rempop0162=$$%0dsqlA() } }
	quit:(SQLCODE '= 0) // error -101 if cursor already open
	for {
		 ;---&sql(FETCH rempop INTO :classname, :propertyname)
 		 ;--- ** SQL PUBLIC Variables: %ROWCOUNT, %ROWID, %msg, SQLCODE
		if $isobject($g(%rempop0162))'=1 { s SQLCODE=-102 } else { do %rempop0162.FET() i SQLCODE=0 { s classname=%rempop0162.sqlcol1,propertyname=%rempop0162.sqlcol2 } }
		quit:(SQLCODE '= 0)
		write !, classname, ?20, propertyname
		// process superclass list (extends)
		set class = ##class(%Dictionary.ClassDefinition).%OpenId(classname)
		set classes(classname) = ""
		set super = class.Super
		if (super [ "%Populate") || (super [ "%Library.Populate") {
			set superList = $listfromstring(super, ",")
			set loc1 = $listfind(superList, "%Populate")
			set loc2 = $listfind(superList, "%Library.Populate")
			set j = 1, superNew = ""
			for i=1:1:$listlength(superList) {
				if (i = loc1) || (i = loc2) {  } // skip, do nothing
				else {
					set $piece(superNew, ",", j) = $list(superList, i)
					set j = j + 1
				}
			}
			write ?40, superNew
			if 'class.SuperIsModified() { set class.Super = superNew }
		}
		// process POPSPEC
		if propertyname '= "" {
			set property = ##class(%Dictionary.PropertyDefinition).IDKEYOpen(classname,propertyname)
			do property.Parameters.RemoveAt("POPSPEC") 
		}
		// save changes or not?
		if commit {
			set stClass = class.%Save()
			set stProp = property.%Save()
		}			
	}
	 ;---&sql(CLOSE rempop)
	if '$isobject($get(%rempop0162)) { set SQLCODE=-102 } else { set SQLCODE=0 kill %rempop0162 }
	quit:(SQLCODE '= 0) // error -102 if cursor not open
	// comment in if really ready to recompile classes
	/* if commit { do $system.OBJ.Compile(.classes, "ck") }
	else { write ! zw classes } */
	write ! zw classes
	quit status }
 q
%0dsqlA()	n %xxsql,%xxoref
	s %xxsql("S",1)="DECLARE rempop CURSOR FOR SELECT parent , name "
	s %xxsql("S",2)="INTO  :i%sqlcol1, :i%sqlcol2"
	s %xxsql("S",3)="FROM %Dictionary . PropertyDefinition WHERE ( parent %STARTSWITH :package ) AND ( parameters LIKE '%POPSPEC%' ) UNION SELECT name , NULL FROM %Dictionary . ClassDefinition WHERE ( name %STARTSWITH :package ) AND ( super LIKE '%Populate%' ) ORDER BY parent"
	s %xxsql("I","%systemInclude")="",%xxsql("NS")="IRISAPP",%xxsql("PToolsCTI")=$LB(,"-1:0:0::0:1")
	s %xxoref=$$BuildQuery^%SYS.SQLSRV(.%xxsql,$lb("Logical","","","Dev",0,"",),",2,rempop,","Dev.Utilities.CLS",1)
	q %xxoref
ResetStorage(package) methodimpl {
	if ($get(package) = "") {
		write !, "Please supply package or sub-package name as argument." return }
	set resultSet = ##class(%Library.ResultSet).%New()
	set resultSet.ClassName = "%Dictionary.ClassDefinition"
	set resultSet.QueryName = "FormWizard"
	// returns names of persistent classes
	do resultSet.%Execute("persistent")
	write !, "Clearing storage definitions for classes:"
	set pattern = "1""" _ package _ """.e"
	while resultSet.%Next() {
		set className = resultSet.%GetData(1)
		continue:(className'?@pattern)
		set class = ##class(%Dictionary.ClassDefinition).%OpenId(className)
		write !, className
		do class.Storages.Clear()
		do class.%Save()
	}
	do resultSet.Close()
	write !, "Compiling classes..."
	do $system.OBJ.CompilePackage(package,"k") }
%sqllistUCQ(t) public	{
	s t("%0dsqlA")=""
}